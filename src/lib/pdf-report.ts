// ============================================================
// Building Intelligence PDF Report Generator
// Produces a branded multi-page PDF from BuildingIntelligence
// Uses jsPDF (same approach as deal-pdf.ts)
// ============================================================

import jsPDF from "jspdf";
import type { BuildingIntelligence } from "./data-fusion-engine";

// ============================================================
// Color Palette
// ============================================================
type RGB = [number, number, number];
const NAVY: RGB = [30, 58, 95];       // #1E3A5F — header bars
const BLUE: RGB = [59, 130, 246];     // #3B82F6 — accents
const DARK: RGB = [15, 23, 42];       // text
const GRAY: RGB = [100, 116, 139];    // secondary text
const LIGHT_GRAY: RGB = [226, 232, 240];
const GREEN: RGB = [22, 163, 74];
const RED: RGB = [220, 38, 38];
const AMBER: RGB = [217, 119, 6];
const WHITE: RGB = [255, 255, 255];
const BG_LIGHT: RGB = [245, 245, 247]; // #F5F5F7

// ============================================================
// Helpers
// ============================================================
const fmt = (n: number) => (n >= 0 ? `$${n.toLocaleString()}` : `-$${Math.abs(n).toLocaleString()}`);
const fmtK = (n: number) => (n >= 1e6 ? `$${(n / 1e6).toFixed(2)}M` : n >= 1000 ? `$${Math.round(n / 1000)}K` : fmt(n));
const fmtDate = (d: string) => {
  if (!d) return "—";
  try {
    return new Intl.DateTimeFormat("en-US", { month: "short", day: "numeric", year: "numeric" }).format(new Date(d));
  } catch {
    return d;
  }
};

function scoreColor(score: number): RGB {
  if (score >= 70) return GREEN;
  if (score >= 40) return AMBER;
  return RED;
}

// ============================================================
// Main Generator
// ============================================================
export function generateBuildingReport(
  intel: BuildingIntelligence,
  options?: { fullReport?: boolean },
): ArrayBuffer {
  const full = options?.fullReport !== false;
  const doc = new jsPDF({ orientation: "portrait", unit: "pt", format: "letter" });
  const W = doc.internal.pageSize.getWidth();
  const H = doc.internal.pageSize.getHeight();
  const ML = 40;
  const MR = 40;
  const CW = W - ML - MR;

  const address = intel.address.raw || intel.bbl;
  const today = new Date().toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" });

  let totalPages = full ? 4 : 2;
  let currentPage = 1;

  // ── Drawing Helpers ──────────────────────────────────────

  function drawFooter(page: number) {
    doc.setDrawColor(...BLUE);
    doc.setLineWidth(0.5);
    doc.line(ML, H - 35, W - MR, H - 35);
    doc.setFontSize(7);
    doc.setFont("helvetica", "normal");
    doc.setTextColor(...GRAY);
    doc.text("Generated by VettdRE \u2014 vettdre.com", ML, H - 22);
    doc.text("Confidential", W / 2, H - 22, { align: "center" });
    doc.text(`Page ${page} of ${totalPages}`, W - MR, H - 22, { align: "right" });
  }

  function drawHeader() {
    doc.setFillColor(...NAVY);
    doc.rect(0, 0, W, 50, "F");
    doc.setTextColor(...WHITE);
    doc.setFontSize(16);
    doc.setFont("helvetica", "bold");
    doc.text("VettdRE", ML, 32);
    doc.setFontSize(9);
    doc.setFont("helvetica", "normal");
    doc.text("Property Intelligence Report", W - MR - 100, 25, { align: "right" });
    doc.text(today, W - MR, 38, { align: "right" });
  }

  function sectionTitle(text: string, yPos: number): number {
    doc.setFontSize(12);
    doc.setTextColor(...BLUE);
    doc.setFont("helvetica", "bold");
    doc.text(text, ML, yPos);
    doc.setDrawColor(...LIGHT_GRAY);
    doc.setLineWidth(0.5);
    doc.line(ML, yPos + 4, W - MR, yPos + 4);
    return yPos + 20;
  }

  function drawScoreBadge(x: number, y: number, label: string, score: number) {
    const color = scoreColor(score);
    const badgeW = 130;
    const badgeH = 32;
    doc.setFillColor(...color);
    doc.roundedRect(x, y, badgeW, badgeH, 4, 4, "F");
    doc.setTextColor(...WHITE);
    doc.setFontSize(8);
    doc.setFont("helvetica", "normal");
    doc.text(label, x + 8, y + 13);
    doc.setFontSize(14);
    doc.setFont("helvetica", "bold");
    doc.text(String(score), x + 8, y + 27);
    doc.setFontSize(8);
    doc.setFont("helvetica", "normal");
    doc.text("/ 100", x + 8 + doc.getTextWidth(String(score)) + 3, y + 27);
  }

  function metricCell(x: number, y: number, label: string, value: string, w: number) {
    const cellH = 40;
    doc.setFillColor(...BG_LIGHT);
    doc.roundedRect(x, y, w, cellH, 3, 3, "F");
    doc.setFontSize(7);
    doc.setTextColor(...GRAY);
    doc.setFont("helvetica", "normal");
    doc.text(label.toUpperCase(), x + 8, y + 14);
    doc.setFontSize(12);
    doc.setTextColor(...DARK);
    doc.setFont("helvetica", "bold");
    doc.text(value, x + 8, y + 30);
  }

  function drawTable(yPos: number, headers: string[], rows: string[][], colWidths?: number[]): number {
    const colCount = headers.length;
    const defaultColW = CW / colCount;
    const widths = colWidths || headers.map(() => defaultColW);
    const rowH = 18;

    // Header row
    doc.setFillColor(...NAVY);
    doc.rect(ML, yPos, CW, rowH, "F");
    doc.setTextColor(...WHITE);
    doc.setFontSize(7.5);
    doc.setFont("helvetica", "bold");
    let cx = ML;
    headers.forEach((h, i) => {
      doc.text(h, cx + 5, yPos + 12);
      cx += widths[i];
    });
    yPos += rowH;

    // Data rows
    rows.forEach((row, ri) => {
      if (ri % 2 === 0) {
        doc.setFillColor(...BG_LIGHT);
        doc.rect(ML, yPos, CW, rowH, "F");
      }
      doc.setTextColor(...DARK);
      doc.setFontSize(7.5);
      doc.setFont("helvetica", "normal");
      cx = ML;
      row.forEach((cell, ci) => {
        const txt = cell.length > 30 ? cell.slice(0, 28) + "..." : cell;
        doc.text(txt, cx + 5, yPos + 12);
        cx += widths[ci];
      });
      yPos += rowH;
    });

    return yPos + 5;
  }

  function labelValue(y: number, label: string, value: string, indent = 0): number {
    doc.setFontSize(8.5);
    doc.setFont("helvetica", "normal");
    doc.setTextColor(...GRAY);
    doc.text(label, ML + indent, y);
    doc.setTextColor(...DARK);
    doc.setFont("helvetica", "bold");
    doc.text(value, ML + 180 + indent, y);
    return y + 14;
  }

  // ── Safely extract values ─────────────────────────────────
  const p = intel.property;
  const units = p.units?.value || 0;
  const yearBuilt = p.yearBuilt?.value || 0;
  const bldgClass = p.buildingClass?.value || "—";
  const floors = p.stories?.value || 0;
  const grossSqft = p.grossSqft?.value || 0;
  const lotSqft = p.lotSqft?.value || 0;
  const assessed = intel.financials.assessedValue?.value || 0;
  const lastSale = intel.financials.lastSale;
  const investScore = intel.investmentSignals.score;
  const distressScore = intel.distressSignals.score;

  // ════════════════════════════════════════════════════════════
  // PAGE 1 — COVER + SUMMARY
  // ════════════════════════════════════════════════════════════
  drawHeader();
  let y = 70;

  // Address block
  doc.setTextColor(...DARK);
  doc.setFontSize(20);
  doc.setFont("helvetica", "bold");
  const addrLines = doc.splitTextToSize(address, CW);
  doc.text(addrLines, ML, y);
  y += addrLines.length * 22;

  doc.setFontSize(10);
  doc.setFont("helvetica", "normal");
  doc.setTextColor(...GRAY);
  const metaLine = [
    intel.bbl ? `BBL ${intel.bbl}` : "",
  ].filter(Boolean).join("  \u2022  ");
  doc.text(metaLine, ML, y);
  y += 20;

  // Score badges
  drawScoreBadge(ML, y, "Investment Score", investScore);
  drawScoreBadge(ML + 145, y, "Distress Score", distressScore);
  y += 48;

  // Key Metrics grid (2 rows × 4 cols)
  y = sectionTitle("Key Metrics", y);
  const metricW = (CW - 30) / 4;
  const metricsRow1 = [
    { label: "Units", value: String(units) },
    { label: "Year Built", value: yearBuilt > 0 ? String(yearBuilt) : "—" },
    { label: "Building Class", value: bldgClass },
    { label: "Floors", value: floors > 0 ? String(floors) : "—" },
  ];
  const metricsRow2 = [
    { label: "Assessed Value", value: assessed > 0 ? fmtK(assessed) : "—" },
    { label: "Last Sale Price", value: lastSale?.price ? fmtK(lastSale.price) : "—" },
    { label: "Last Sale Date", value: lastSale?.date ? fmtDate(lastSale.date) : "—" },
    { label: "Lot Size (SF)", value: lotSqft > 0 ? lotSqft.toLocaleString() : "—" },
  ];

  metricsRow1.forEach((m, i) => metricCell(ML + i * (metricW + 10), y, m.label, m.value, metricW));
  y += 50;
  metricsRow2.forEach((m, i) => metricCell(ML + i * (metricW + 10), y, m.label, m.value, metricW));
  y += 58;

  // Ownership
  y = sectionTitle("Ownership", y);
  const owner = intel.ownership;
  y = labelValue(y, "Owner:", owner.likelyOwner.entityName || owner.registeredOwner || "Unknown");
  if (owner.likelyOwner.likelyPerson && owner.likelyOwner.likelyPerson !== owner.likelyOwner.entityName) {
    y = labelValue(y, "Individual:", owner.likelyOwner.likelyPerson);
  }
  if (owner.likelyOwner.llcName) {
    y = labelValue(y, "Entity:", owner.likelyOwner.llcName);
  }
  if (owner.hpdRegistration?.managingAgent) {
    y = labelValue(y, "Managing Agent:", owner.hpdRegistration.managingAgent);
  }
  if (intel.fannieMaeLoan) {
    y = labelValue(y, "GSE-Backed:", intel.fannieMaeLoan.isOwnedByFannieMae ? "Yes (Fannie Mae)" : "No");
  }
  y = labelValue(y, "Confidence:", `${owner.confidence}%`);
  y += 5;

  // Zoning & FAR
  const zoning = p.zoning?.value;
  const builtFAR = p.builtFAR?.value;
  const maxFAR = p.maxFAR?.value;
  if (zoning || builtFAR || maxFAR) {
    y = sectionTitle("Zoning & Development", y);
    if (zoning) y = labelValue(y, "Zoning:", zoning);
    if (builtFAR) y = labelValue(y, "Built FAR:", builtFAR.toFixed(2));
    if (maxFAR) y = labelValue(y, "Max FAR:", maxFAR.toFixed(2));
    if (builtFAR && maxFAR && builtFAR < maxFAR) {
      const excessPct = Math.round((1 - builtFAR / maxFAR) * 100);
      y = labelValue(y, "Unused FAR:", `${excessPct}% — development potential`);
    }
    if (p.rentStabilizedUnits?.value) {
      y = labelValue(y, "Rent Stabilized:", `${p.rentStabilizedUnits.value} units`);
    }
  }

  drawFooter(currentPage);

  // ════════════════════════════════════════════════════════════
  // PAGE 2 — VIOLATIONS & COMPLIANCE
  // ════════════════════════════════════════════════════════════
  doc.addPage();
  currentPage++;
  drawHeader();
  y = 70;

  // HPD Violations
  y = sectionTitle("HPD Violations", y);
  const v = intel.compliance.hpdViolations;
  y = labelValue(y, "Total Open:", String(v.open));
  y = labelValue(y, "Class A (Non-Hazardous):", String(v.classA));
  y = labelValue(y, "Class B (Hazardous):", String(v.classB));
  y = labelValue(y, "Class C (Immediately Hazardous):", String(v.classC));
  y = labelValue(y, "Total (All Time):", String(v.total));

  if (v.recentViolations && v.recentViolations.length > 0) {
    y += 5;
    const violHeaders = ["Date", "Class", "Status", "Description"];
    const violWidths = [80, 50, 70, CW - 200];
    const violRows = v.recentViolations.slice(0, 8).map((rv: any) => [
      fmtDate(rv.inspectionDate || rv.approvedDate || ""),
      rv.violationClass || rv.class || "—",
      rv.currentStatus || rv.status || "—",
      rv.novDescription || rv.description || "—",
    ]);
    y = drawTable(y, violHeaders, violRows, violWidths);
  }
  y += 10;

  // DOB Permits
  y = sectionTitle("DOB Permits & Filings", y);
  const permits = intel.compliance.dobPermits;
  y = labelValue(y, "Active Permits:", String(permits.active));

  if (permits.recent && permits.recent.length > 0) {
    y += 5;
    const permHeaders = ["Date", "Type", "Description"];
    const permWidths = [80, 100, CW - 180];
    const permRows = permits.recent.slice(0, 6).map((rp: any) => [
      fmtDate(rp.issuanceDate || rp.filingDate || ""),
      rp.jobType || rp.type || "—",
      rp.jobDescription || rp.description || "—",
    ]);
    y = drawTable(y, permHeaders, permRows, permWidths);
  }
  y += 10;

  // Compliance Status
  y = sectionTitle("Compliance Status", y);
  y = labelValue(y, "RPIE Filing:", intel.compliance.rpieStatus === "compliant" ? "Compliant" : intel.compliance.rpieStatus === "non_compliant" ? "Non-Compliant" : "Unknown");
  if (intel.compliance.rpieYearsMissed.length > 0) {
    y = labelValue(y, "RPIE Years Missed:", intel.compliance.rpieYearsMissed.join(", "));
  }
  y = labelValue(y, "LL84 Energy:", intel.compliance.ll84Status === "reported" ? "Reported" : intel.compliance.ll84Status === "not_reported" ? "Not Reported" : "Not Required");
  if (intel.energy) {
    if (intel.energy.energyStarGrade) y = labelValue(y, "Energy Star Grade:", intel.energy.energyStarGrade);
    if (intel.energy.siteEUI > 0) y = labelValue(y, "Site EUI:", `${intel.energy.siteEUI.toFixed(1)} kBTU/sf`);
    if (intel.energy.ll97Status !== "compliant") {
      y = labelValue(y, "LL97 Risk:", intel.energy.ll97Status === "non_compliant" ? "Non-Compliant" : "At Risk (2030)");
      if (intel.energy.ll97PenaltyEstimate > 0) {
        y = labelValue(y, "Est. LL97 Penalty:", fmtK(intel.energy.ll97PenaltyEstimate) + "/yr");
      }
    }
  }

  // 311 Complaints
  if (intel.compliance.complaints311 > 0) {
    y += 10;
    y = sectionTitle("311 Complaints", y);
    y = labelValue(y, "Total:", String(intel.compliance.complaints311));
    y = labelValue(y, "Recent (2yr):", String(intel.compliance.recentComplaints));
    if (intel.compliance.topComplaintTypes.length > 0) {
      const topTypes = intel.compliance.topComplaintTypes.slice(0, 5).map(t => `${t.type} (${t.count})`).join(", ");
      y = labelValue(y, "Top Types:", topTypes);
    }
  }

  // Litigation
  if (intel.compliance.litigationCount > 0) {
    y += 10;
    y = sectionTitle("HPD Litigation", y);
    y = labelValue(y, "Total Cases:", String(intel.compliance.litigationCount));
    y = labelValue(y, "Open Cases:", String(intel.compliance.openLitigation));
    if (intel.compliance.harassmentFinding) {
      doc.setTextColor(...RED);
      doc.setFont("helvetica", "bold");
      doc.setFontSize(8.5);
      doc.text("HARASSMENT FINDING ON RECORD", ML, y);
      doc.setTextColor(...DARK);
      y += 14;
    }
  }

  drawFooter(currentPage);

  // ════════════════════════════════════════════════════════════
  // PAGE 3 — VALUATION & MARKET (Pro+ only)
  // ════════════════════════════════════════════════════════════
  if (full) {
    doc.addPage();
    currentPage++;
    drawHeader();
    y = 70;

    // Comparable Sales
    y = sectionTitle("Comparable Sales", y);
    if (intel.comps && intel.comps.count > 0) {
      const estValue = intel.comps.avgPricePerUnit * units;
      y = labelValue(y, "Estimated Value:", estValue > 0 ? fmtK(estValue) : "—");
      y = labelValue(y, "Avg $/Unit:", fmtK(intel.comps.avgPricePerUnit));
      y = labelValue(y, "Median $/Unit:", fmtK(intel.comps.medianPricePerUnit));
      if (intel.comps.avgPricePerSqft > 0) y = labelValue(y, "Avg $/SF:", fmt(Math.round(intel.comps.avgPricePerSqft)));
      y = labelValue(y, "Subject vs Market:", `${intel.comps.subjectVsMarket > 0 ? "+" : ""}${Math.round(intel.comps.subjectVsMarket)}%`);
      y = labelValue(y, "Comp Count:", String(intel.comps.count));

      if (intel.comps.recentComps.length > 0) {
        y += 5;
        const compHeaders = ["Address", "Sale Price", "Date", "Units", "$/Unit", "Dist"];
        const compWidths = [CW - 310, 80, 65, 40, 65, 60];
        const compRows = intel.comps.recentComps.slice(0, 6).map((c: any) => [
          c.address || "—",
          c.price ? fmtK(c.price) : "—",
          fmtDate(c.date || ""),
          String(c.units || "—"),
          c.pricePerUnit ? fmtK(c.pricePerUnit) : "—",
          c.distance ? `${c.distance.toFixed(1)}mi` : "—",
        ]);
        y = drawTable(y, compHeaders, compRows, compWidths);
      }
    } else {
      doc.setFontSize(9);
      doc.setTextColor(...GRAY);
      doc.text("No comparable sales data available.", ML, y);
      y += 18;
    }
    y += 10;

    // Market Trends
    y = sectionTitle("Market Trends", y);
    if (intel.marketTrends) {
      const mt = intel.marketTrends;
      if (mt.localAppreciation1Yr != null) y = labelValue(y, "Local Appreciation (1yr):", `${mt.localAppreciation1Yr > 0 ? "+" : ""}${mt.localAppreciation1Yr}%`);
      y = labelValue(y, "Metro Appreciation (1yr):", `+${mt.metroAppreciation1Yr}%`);
      y = labelValue(y, "Trend:", mt.trend.charAt(0).toUpperCase() + mt.trend.slice(1));
      if (mt.marketTemperature) {
        y = labelValue(y, "Market Temperature:", mt.marketTemperature.charAt(0).toUpperCase() + mt.marketTemperature.slice(1));
      }
      if (mt.medianDaysOnMarket != null) y = labelValue(y, "Median Days on Market:", String(mt.medianDaysOnMarket));
    } else {
      doc.setFontSize(9);
      doc.setTextColor(...GRAY);
      doc.text("Market trend data not available for this area.", ML, y);
      y += 18;
    }
    y += 10;

    // Sales History
    if (intel.financials.allSales.length > 0) {
      y = sectionTitle("Sales History", y);
      const saleHeaders = ["Date", "Sale Price", "Buyer", "Seller", "Type"];
      const saleWidths = [70, 85, CW / 2 - 100, CW / 2 - 100, 55];
      const saleRows = intel.financials.allSales.slice(0, 6).map(s => [
        fmtDate(s.date),
        s.price > 0 ? fmtK(s.price) : "—",
        s.buyer || "—",
        s.seller || "—",
        s.docType || "—",
      ]);
      y = drawTable(y, saleHeaders, saleRows, saleWidths);
    }

    drawFooter(currentPage);

    // ════════════════════════════════════════════════════════════
    // PAGE 4 — RENOVATION & INVESTMENT THESIS
    // ════════════════════════════════════════════════════════════
    doc.addPage();
    currentPage++;
    drawHeader();
    y = 70;

    // Renovation Analysis
    y = sectionTitle("Renovation Analysis", y);
    if (intel.renovationEstimate) {
      const reno = intel.renovationEstimate;
      const levelLabel = reno.recommendedLevel.charAt(0).toUpperCase() + reno.recommendedLevel.slice(1);
      y = labelValue(y, "Recommended Level:", levelLabel);
      y = labelValue(y, "Estimated Cost:", fmtK(reno.totalCost));
      y = labelValue(y, "Cost Per Unit:", fmtK(reno.costPerUnit));
      if (reno.arv > 0) {
        y = labelValue(y, "After Repair Value:", fmtK(reno.arv));
        y = labelValue(y, "Renovation ROI:", `${reno.roi}%`);
      }

      if (reno.conditionSignals.length > 0) {
        y += 5;
        doc.setFontSize(8.5);
        doc.setTextColor(...GRAY);
        doc.setFont("helvetica", "italic");
        reno.conditionSignals.forEach(sig => {
          doc.text(`\u2022  ${sig}`, ML + 10, y);
          y += 13;
        });
        doc.setFont("helvetica", "normal");
      }
    } else {
      doc.setFontSize(9);
      doc.setTextColor(...GRAY);
      doc.text("Renovation estimate not available.", ML, y);
      y += 18;
    }
    y += 10;

    // STR Potential
    if (intel.strProjection) {
      y = sectionTitle("Short-Term Rental Potential", y);
      const str = intel.strProjection;
      y = labelValue(y, "STR Revenue:", `$${str.monthlySTRPerUnit.toLocaleString()}/mo per unit (${str.strPremium > 0 ? "+" : ""}${str.strPremium}% premium over LTR)`);
      y = labelValue(y, "LTR Revenue:", `$${str.monthlyLTRPerUnit.toLocaleString()}/mo per unit`);
      if (str.annualDelta !== 0) {
        y = labelValue(y, "Annual Delta:", `${str.annualDelta > 0 ? "+" : "-"}$${Math.abs(str.annualDelta) >= 1e6 ? (Math.abs(str.annualDelta) / 1e6).toFixed(2) + "M" : Math.round(Math.abs(str.annualDelta) / 1000).toLocaleString() + "K"}/yr`);
      }
      doc.setFontSize(8);
      doc.setTextColor(...GRAY);
      doc.setFont("helvetica", "italic");
      doc.text("Subject to NYC Local Law 18 restrictions on short-term rentals.", ML + 10, y);
      doc.setFont("helvetica", "normal");
      y += 18;
      y += 10;
    }

    // Investment Signals
    y = sectionTitle("Investment Signals", y);
    if (intel.investmentSignals.signals.length > 0) {
      doc.setFontSize(8.5);
      intel.investmentSignals.signals.forEach(sig => {
        doc.setTextColor(...GREEN);
        doc.setFont("helvetica", "bold");
        doc.text("\u25B2", ML, y);
        doc.setTextColor(...DARK);
        doc.setFont("helvetica", "normal");
        doc.text(sig.description, ML + 12, y);
        y += 13;
      });
    } else {
      doc.setFontSize(9);
      doc.setTextColor(...GRAY);
      doc.text("No investment signals detected.", ML, y);
      y += 18;
    }
    y += 10;

    // Distress Signals
    y = sectionTitle("Distress Signals", y);
    if (intel.distressSignals.signals.length > 0) {
      doc.setFontSize(8.5);
      intel.distressSignals.signals.forEach(sig => {
        const sigColor = sig.severity === "high" ? RED : sig.severity === "medium" ? AMBER : GRAY;
        doc.setTextColor(...sigColor);
        doc.setFont("helvetica", "bold");
        doc.text("\u25BC", ML, y);
        doc.setTextColor(...DARK);
        doc.setFont("helvetica", "normal");
        doc.text(sig.description, ML + 12, y);
        y += 13;
      });
    } else {
      doc.setFontSize(9);
      doc.setTextColor(...GRAY);
      doc.text("No distress signals detected.", ML, y);
      y += 18;
    }
    y += 10;

    // Data Sources
    y = sectionTitle("Data Sources", y);
    doc.setFontSize(8);
    doc.setTextColor(...GRAY);
    doc.setFont("helvetica", "normal");
    const sourceLine = intel.dataSources.join("  \u2022  ");
    const sourceLines = doc.splitTextToSize(sourceLine, CW);
    doc.text(sourceLines, ML, y);
    y += sourceLines.length * 11 + 10;

    // Disclaimer
    doc.setFontSize(7);
    doc.setTextColor(...GRAY);
    doc.setFont("helvetica", "italic");
    const disclaimer = "This report is generated from publicly available data sources and AI analysis. All estimates are approximate and should not be relied upon as the sole basis for investment decisions. VettdRE makes no warranty regarding accuracy or completeness of the data. Consult qualified professionals before making investment decisions.";
    const disclaimerLines = doc.splitTextToSize(disclaimer, CW);
    doc.text(disclaimerLines, ML, y);

    drawFooter(currentPage);
  }

  // Return as ArrayBuffer
  return doc.output("arraybuffer");
}
